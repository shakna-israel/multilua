1 Introduction
1.1 Library Design
  1.1.1 No Enums
  1.1.2 Memory Overhead
  1.1.3 Cleaning Up
  1.1.4 Multilua State
  1.1.5 Safety
2 Metamethods
2.1 Length Operator
2.2 Index Operator
2.3 New Index Operator
2.4 Call Operator
3 Definitions
3.1 multilua.new
3.2 multilua.close
3.3 multilua.fetchable
Index
1 Introduction
**************

1.1 Library Design
==================

The overall design of the library is such that it should mostly match
Lua 5.3’s C API, and thus be familiar to the programmer.

   The library generally follows one of the two forms:

multilua.function(multilua_state, ...)

multilua_state:function(...)

   Most functions will return ‘nil’ upon failure, and either some
result, or ‘true’ upon success. This should allow the programmer to wrap
most function calls inside either some sort of error handling, or a
simple ‘assert’.

   However there are some differences to the C-API, and some design
challenges, that the programmer should be aware of.

1.1.1 No Enums
--------------

When it comes to places where Lua would usually make use of an ‘enum’,
we instead tend to make use of strings, as would usually be done from
the Lua side of things.

   For example:

local multilua = require "multilua"

local obj = assert(multilua.new())

obj:pushinteger(10)
obj:pushinteger(11)
print(obj:compare(-1, -2, "=="))

   Usually, in the C-API, you would pass ‘LUA_OPEQ’, but instead, we
pass the string ‘"=="’.

1.1.2 Memory Overhead
---------------------

To simplify making use of the API, and to prevent a number of memory
errors, ‘multilua’ will call ‘lua_checkstack’ for you automatically.

   Whilst this makes it much safer to use the API, it also means that
‘multilua’ may sometimes use more memory than is strictly necessary.

   Whilst the overhead does not tend to be significant, there is some
overhead, and the programmer may care about that.

1.1.3 Cleaning Up
-----------------

‘multilua’ states are Garbage-Collected values.

   This means that whilst you can and should cleanup a state when you
don’t need it anymore, by calling the close method, the host Lua’s
Garbage Collector will also call this method when it feels the need to
get rid of a ‘multilua’ state.

   Like all GC collections, this may have performance ramifications for
your program - which you can work around by calling close yourself.

1.1.4 Multilua State
--------------------

The ‘multilua’ state object is a table, with a bunch of methods attached
to it, and a single value located at the key ‘"self"’.

   This ‘"self"’ value is a lightuserdata value. If the programmer feels
the need to modify or play with this in any way, shape, or form, then
they will be entering the terrifying land of Undefined Behaviour, and
nobody can help them.

   In short: don’t touch it.

   However, if you are keen on messing with things, and possessing less
than average intelligence, then the "self" value is actually what it
seems like - a C-pointer to a lua_State.

   Note: In the case of an invalid ‘multilua’ state (such as one that
has been closed), then "self" may actually be ‘nil’.

1.1.5 Safety
------------

Whilst ‘multilua’ does attempt to protect you from doing downright
idiotic things, quite a lot of the API is still using memory pointers,
which are treated exactly as what they are.

   This means if the programmer does something idiotic, like passing the
wrong kind of pointer to the wrong function, they will still have things
misbehave as if they had done that in C.

   Which, unfortunately, means segmentation faults, memory corruption
errors, and all sorts of other goodies are entirely possible.

   ‘multilua’ cannot protect you against everything.

2 Metamethods
*************

‘multilua’ includes a variety of metamethods to make programming feel
simpler, and closer to what one would expect in Lua, instead of only
like the C-API.

   These metamethods in no way restrict the power of what you can do -
they simple abstract away some of the fiddlier bits of the API.



                                 — — —


2.1 Length Operator
===================

Lua’s length operator has been overridden to match ‘multilua.gettop’,
that is, it’ll return the current size of the stack for the given
object.

local multilua = require "multilua"

local obj = multilua.new()

assert(#obj == obj:gettop())



                                 — — —


2.2 Index Operator
==================

Lua’s index fetching has been overridden so that ‘integer’ keys will
return the type found at that position on the stack. String keys will
continue to operate as expected.

local multilua = require "multilua"

local obj = multilua.new()

obj:pushstring("Hello")

assert(obj[-1] == 'string')



                                 — — —


2.3 New Index Operator
======================

Lua’s new index operator has been overridden so that ‘integer’ keys will
operate on the stack. String keys will continue to operate as expected.

   WARNING: If a value being passed cannot simply be copied, it will
raise an error.

   This can currently copy the current values:

   • ‘nil’
   • ‘integer’
   • ‘number’
   • ‘boolean’
   • ‘string’
   • ‘CFunction’
   • ‘lightuserdata’

local multilua = require "multilua"

local obj = multilua.new()

obj[#obj + 1] = 10



                                 — — —


2.4 Call Operator
=================

The ‘metalua’ state object can be called, with an argument of the index,
to return a copyable value from the stack. This value is not modified or
popped.

   See also, *note multilua.fetchable: Definitions.

   WARNING: For Lua functions, tables, full userdata, threads, if the
originating state is closed, and then they are attempted to be used,
will result in Undefined Behaviour. This is because those values are
‘reference’ types, as is normal in Lua.

local multilua = require "multilua"

local obj = multilua.new()

obj[#obj + 1] = 10

assert(obj(-1) == 10)

3 Definitions
*************

3.1 multilua.new
================

 -- Function: multilua.new -> nil|table

     This function attempts to create a fresh ‘multilua’ state object.

     Returns:

        • ‘nil’ - Something went wrong. Probably a memory error.
        • ‘table’ - The ‘multilua’ state object.



                                 — — —


3.2 multilua.close
==================

 -- Function: multilua.close <table:state> -> nil

     This function, given a ‘multilua’ ‘state’, closes the state.

     ‘state['self']’ should become ‘nil’ after this function is called.

     WARNING: This function invokes a garbage collection on ‘state’, and
     therefore may have a performance impact.

     WARNING: If the ‘state’ is the host Lua’s ‘state’, this function is
     a no-op.

     Note: Whilst the ‘state’ attempts to prove that it is closed, use
     after closing should be considered a code smell.



                                 — — —


3.3 multilua.fetchable
======================

 -- Function: multilua.fetchable <table:state> [<integer:index>] ->
          nil|boolean

     Given a ‘multilua state’ and a valid ‘index’, returns whether or
     not the value can be _safely_ copied from ‘state’ to the host Lua
     state.

     If no ‘index’ is provided, defaults to ‘-1’.

     Returns:

        • ‘nil’ - An error ocurred.
             • The ‘index’ may be invalid.
             • The ‘state’ may be invalid.
        • ‘false’ - The value cannot be safely copied. You will need to
          manually deepcopy it, or you will receive only a reference.
        • ‘true’ - The value can be safely copied.

Index
*****

* Menu:

* chapter, Definitions:                  Definitions.         (line 228)
* chapter, Introduction:                 Introduction.        (line  19)
* chapter, Metamethods:                  Metamethods.         (line 124)
* function, multilua.close:              Definitions.         (line 249)
* function, multilua.fetchable:          Definitions.         (line 272)
* function, multilua.new:                Definitions.         (line 232)
* multilua state:                        Definitions.         (line 241)
* multilua.close:                        Definitions.         (line 249)
* multilua.fetchable:                    Definitions.         (line 272)
* multilua.new:                          Definitions.         (line 232)

