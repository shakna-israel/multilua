1 Introduction
1.1 Library Design
  1.1.1 No Enums
  1.1.2 Memory Overhead
  1.1.3 Cleaning Up
  1.1.4 Multilua State
2 Definitions
Index
1 Introduction
**************

1.1 Library Design
==================

The overall design of the library is such that it should mostly match
Lua 5.3’s C API, and thus be familiar to the programmer.

   The library generally follows one of the two forms:

multilua.function(multilua_state, ...)

multilua_state:function(...)

   Most functions will return ‘nil’ upon failure, and either some
result, or ‘true’ upon success. This should allow the programmer to wrap
most function calls inside either some sort of error handling, or a
simple ‘assert’.

   However there are some differences to the C-API, and some design
challenges, that the programmer should be aware of.

1.1.1 No Enums
--------------

When it comes to places where Lua would usually make use of an ‘enum’,
we instead tend to make use of strings, as would usually be done from
the Lua side of things.

   For example:

local multilua = require "multilua"

local obj = assert(multilua.new())

obj:pushinteger(10)
obj:pushinteger(11)
print(obj:compare(-1, -2, "=="))

   Usually, in the C-API, you would pass ‘LUA_OPEQ’, but instead, we
pass the string ‘"=="’.

1.1.2 Memory Overhead
---------------------

To simplify making use of the API, and to prevent a number of memory
errors, ‘multilua’ will call ‘lua_checkstack’ for you automatically.

   Whilst this makes it much safer to use the API, it also means that
‘multilua’ may sometimes use more memory than is strictly necessary.

   Whilst the overhead does not tend to be significant, there is some
overhead, and the programmer may care about that.

1.1.3 Cleaning Up
-----------------

‘multilua’ states are Garbage-Collected values.

   This means that whilst you can and should cleanup a state when you
don’t need it anymore, by calling the close method, the host Lua’s
Garbage Collector will also call this method when it feels the need to
get rid of a ‘multilua’ state.

   Like all GC collections, this may have performance ramifications for
your program - which you can work around by calling close yourself.

1.1.4 Multilua State
--------------------

The ‘multilua’ state object is a table, with a bunch of methods attached
to it, and a single value located at the key ‘"self"’.

   This ‘"self"’ value is a lightuserdata value. If the programmer feels
the need to modify or play with this in any way, shape, or form, then
they will be entering the terrifying land of Undefined Behaviour, and
nobody can help them.

   In short: don’t touch it.

   However, if you are keen on messing with things, and possessing less
than average intelligence, then the "self" value is actually what it
seems like - a C-pointer to a lua_State.

   Note: In the case of an invalid ‘multilua’ state (such as one that
has been closed), then "self" may actually be ‘nil’.

2 Definitions
*************

Index
*****

* Menu:

* chapter, Definitions:                  Definitions.          (line 98)
* chapter, Introduction:                 Introduction.         (line 10)

