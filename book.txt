1 Introduction
1.1 Library Design
  1.1.1 No Enums
  1.1.2 Memory Overhead
  1.1.3 Cleaning Up
  1.1.4 Multilua State
  1.1.5 Safety
2 Definitions
2.1 multilua.new
2.2 multilua.close
Index
1 Introduction
**************

1.1 Library Design
==================

The overall design of the library is such that it should mostly match
Lua 5.3’s C API, and thus be familiar to the programmer.

   The library generally follows one of the two forms:

multilua.function(multilua_state, ...)

multilua_state:function(...)

   Most functions will return ‘nil’ upon failure, and either some
result, or ‘true’ upon success. This should allow the programmer to wrap
most function calls inside either some sort of error handling, or a
simple ‘assert’.

   However there are some differences to the C-API, and some design
challenges, that the programmer should be aware of.

1.1.1 No Enums
--------------

When it comes to places where Lua would usually make use of an ‘enum’,
we instead tend to make use of strings, as would usually be done from
the Lua side of things.

   For example:

local multilua = require "multilua"

local obj = assert(multilua.new())

obj:pushinteger(10)
obj:pushinteger(11)
print(obj:compare(-1, -2, "=="))

   Usually, in the C-API, you would pass ‘LUA_OPEQ’, but instead, we
pass the string ‘"=="’.

1.1.2 Memory Overhead
---------------------

To simplify making use of the API, and to prevent a number of memory
errors, ‘multilua’ will call ‘lua_checkstack’ for you automatically.

   Whilst this makes it much safer to use the API, it also means that
‘multilua’ may sometimes use more memory than is strictly necessary.

   Whilst the overhead does not tend to be significant, there is some
overhead, and the programmer may care about that.

1.1.3 Cleaning Up
-----------------

‘multilua’ states are Garbage-Collected values.

   This means that whilst you can and should cleanup a state when you
don’t need it anymore, by calling the close method, the host Lua’s
Garbage Collector will also call this method when it feels the need to
get rid of a ‘multilua’ state.

   Like all GC collections, this may have performance ramifications for
your program - which you can work around by calling close yourself.

1.1.4 Multilua State
--------------------

The ‘multilua’ state object is a table, with a bunch of methods attached
to it, and a single value located at the key ‘"self"’.

   This ‘"self"’ value is a lightuserdata value. If the programmer feels
the need to modify or play with this in any way, shape, or form, then
they will be entering the terrifying land of Undefined Behaviour, and
nobody can help them.

   In short: don’t touch it.

   However, if you are keen on messing with things, and possessing less
than average intelligence, then the "self" value is actually what it
seems like - a C-pointer to a lua_State.

   Note: In the case of an invalid ‘multilua’ state (such as one that
has been closed), then "self" may actually be ‘nil’.

1.1.5 Safety
------------

Whilst ‘multilua’ does attempt to protect you from doing downright
idiotic things, quite a lot of the API is still using memory pointers,
which are treated exactly as what they are.

   This means if the programmer does something idiotic, like passing the
wrong kind of pointer to the wrong function, they will still have things
misbehave as if they had done that in C.

   Which, unfortunately, means segmentation faults, memory corruption
errors, and all sorts of other goodies are entirely possible.

   ‘multilua’ cannot protect you against everything.

2 Definitions
*************

2.1 multilua.new
================

 -- Function: multilua.new -> nil|table

     This function attempts to create a fresh ‘multilua’ state object.

     It returns one of:

        • ‘nil’ - Something went wrong. Probably a memory error.
        • ‘table’ - The ‘multilua’ state object.



                                 — — —


2.2 multilua.close
==================

 -- Function: multilua.close state -> nil

     This function, given a ‘multilua’ STATE, closes the state.

     STATE[’SELF’] should become ‘nil’ after this function is called.

     WARNING: This function invokes a garbage collection on STATE, and
     therefore may have a performance impact.

     WARNING: If the STATE is the host Lua’s STATE, this function is a
     no-op.

     Note: Whilst the STATE attempts to prove that it is closed, use
     after closing should be considered a code smell.



                                 — — —


Index
*****

* Menu:

* chapter, Definitions:                  Definitions.         (line 117)
* chapter, Introduction:                 Introduction.        (line  13)
* function, multilua.close:              Definitions.         (line 138)
* function, multilua.new:                Definitions.         (line 121)
* multilua state:                        Definitions.         (line 130)
* multilua.close:                        Definitions.         (line 138)
* multilua.new:                          Definitions.         (line 121)

